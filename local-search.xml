<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>应用无响应（ANR）</title>
    <link href="/2020/07/02/%E5%BA%94%E7%94%A8%E6%97%A0%E5%93%8D%E5%BA%94/"/>
    <url>/2020/07/02/%E5%BA%94%E7%94%A8%E6%97%A0%E5%93%8D%E5%BA%94/</url>
    
    <content type="html"><![CDATA[<h3 id="如何避免-应用无响应-ANR"><a href="#如何避免-应用无响应-ANR" class="headerlink" title="如何避免 应用无响应(ANR)"></a>如何避免 应用无响应(ANR)</h3><p>为耗时较长的操作创建工作线程的最有效方法是使用 AsyncTask 类。只需扩展 AsyncTask 并实现 doInBackground() 方法即可执行相应操作。要向用户发布进度变化，您可以调用 publishProgress()，它会调用 onProgressUpdate() 回调方法。通过 onProgressUpdate()（在界面线程中运行）的实现，您可以向用户发送通知。例如：</p><pre><code class="hljs angelscript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">DownloadFilesTask</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AsyncTask</span>&lt;<span class="hljs-symbol">URL, <span class="hljs-symbol">Integer</span>, <span class="hljs-symbol">Long</span></span>&gt; &#123;    <span class="hljs-comment">// Do the long-running work in here</span>    <span class="hljs-keyword">protected</span> Long doInBackground(URL... urls) &#123;        <span class="hljs-built_in">int</span> count = urls.length;        long totalSize = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;            totalSize += Downloader.downloadFile(urls[i]);            publishProgress((<span class="hljs-built_in">int</span>) ((i / (<span class="hljs-built_in">float</span>) count) * <span class="hljs-number">100</span>));            <span class="hljs-comment">// Escape early if cancel() is called</span>            <span class="hljs-keyword">if</span> (isCancelled()) <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">return</span> totalSize;    &#125;    <span class="hljs-comment">// This is called each time you call publishProgress()</span>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> onProgressUpdate(Integer... progress) &#123;        setProgressPercent(progress[<span class="hljs-number">0</span>]);    &#125;    <span class="hljs-comment">// This is called when doInBackground() is finished</span>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> onPostExecute(Long result) &#123;        showNotification(<span class="hljs-string">"Downloaded "</span> + result + <span class="hljs-string">" bytes"</span>);    &#125;&#125;</code></pre><p>要执行此工作线程，只需创建一个实例并调用 execute() 即可：<br><code>new DownloadFilesTask().execute(url1, url2, url3);</code></p>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>官方文档摘录</tag>
      
      <tag>进程和线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Intent</title>
    <link href="/2020/07/02/Intent/"/>
    <url>/2020/07/02/Intent/</url>
    
    <content type="html"><![CDATA[<p>Keyword: 闹钟, 日历, 相机, 联系人, 文件存储, 地图, 音乐和视频, 新笔记, 电话, 设置发送短信</p><a id="more"></a><h2 id="Intent和Intent过滤器"><a href="#Intent和Intent过滤器" class="headerlink" title="Intent和Intent过滤器"></a>Intent和Intent过滤器</h2><blockquote><p>要仅设置数据 URI，请调用 <code>setData()</code>。要仅设置 MIME 类型，请调用 <code>setType()</code>。如有必要，可以使用 <code>setDataAndType()</code> 同时显式设置二者。若要同时设置 URI 和 MIME 类型，请勿调用 <code>setData()</code> 和 <code>setType()</code>，因为它们会互相抵消彼此的值。请始终使用 <code>setDataAndType()</code> 同时设置 URI 和 MIME 类型。  </p></blockquote><blockquote><p>要接收隐式 Intent，必须将 CATEGORY_DEFAULT 类别包括在 Intent 过滤器中。方法 startActivity() 和 startActivityForResult() 将按照其声明 CATEGORY_DEFAULT 类别的方式处理所有 Intent。如果未在 Intent 过滤器中声明此类别，则隐式 Intent 不会解析为您的 Activity。  </p></blockquote><h3 id="Intent-解析"><a href="#Intent-解析" class="headerlink" title="Intent 解析"></a>Intent 解析</h3><h4 id="操作测试"><a href="#操作测试" class="headerlink" title="操作测试"></a>操作测试</h4><p>要指定接受的 Intent 操作，Intent 过滤器既可以不声明任何 <code>&lt;action&gt;</code> 元素，也可以声明多个此类元素。要通过此过滤器，在 Intent 中指定的操作必须与过滤器中列出的某一操作匹配。</p><blockquote><p>如果该过滤器未列出任何操作，则 Intent 没有任何匹配项，因此所有 Intent 均无法通过测试。但是，如果 Intent 未指定操作，则只要过滤器内包含至少一项操作，就可以通过测试。</p></blockquote><h4 id="类别测试"><a href="#类别测试" class="headerlink" title="类别测试"></a>类别测试</h4><p>要指定接受的 Intent 类别，Intent 过滤器既可以不声明任何 <code>&lt;category&gt;</code> 元素，也可以声明多个此类元素。若要使 Intent 通过类别测试，则 Intent 中的<strong>每个</strong>类别均必须与过滤器中的类别匹配。反之则未必然，Intent 过滤器声明的类别可以超出 Intent 中指定的数量，且 Intent 仍会通过测试。因此，不含类别的 Intent 应当始终会通过此测试，无论过滤器中声明何种类别均是如此。</p><h4 id="数据测试"><a href="#数据测试" class="headerlink" title="数据测试"></a>数据测试</h4><p>要指定接受的 Intent 数据，Intent 过滤器既可以不声明任何 <code>&lt;data&gt;</code> 元素，也可以声明多个此类元素。每个 <code>&lt;data&gt;</code> 元素均可指定 URI 结构和数据类型（MIME 媒体类型）。URI 的每个部分都是一个单独的属性：<code>scheme</code>、<code>host</code>、<code>port</code> 和 <code>path</code>：<code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;</code>。<br>在 <code>&lt;data&gt;</code> 元素中，上述每个属性均为可选，但存在线性依赖关系：</p><ul><li>如果未指定架构，则会忽略主机。</li><li>如果未指定主机，则会忽略端口。</li><li>如果未指定架构和主机，则会忽略路径。  </li></ul><p>数据测试会将 Intent 中的 URI 和 MIME 类型与过滤器中指定的 URI 和 MIME 类型进行比较。规则如下：</p><ol><li>仅当过滤器未指定任何 URI 或 MIME 类型时，不含 URI 和 MIME 类型的 Intent 才会通过测试。</li><li>对于包含 URI 但不含 MIME 类型（既未显式声明，也无法通过 URI 推断得出）的 Intent，仅当其 URI 与过滤器的 URI 格式匹配、且过滤器同样未指定 MIME 类型时，才会通过测试。</li><li>仅当过滤器列出相同的 MIME 类型且未指定 URI 格式时，包含 MIME 类型但不含 URI 的 Intent 才会通过测试。</li><li>仅当 MIME 类型与过滤器中列出的类型匹配时，同时包含 URI 类型和 MIME 类型（通过显式声明，或可以通过 URI 推断得出）的 Intent 才会通过测试的 MIME 类型部分。如果 Intent 的 URI 与过滤器中的 URI 匹配，或者如果 Intent 具有 <code>content:</code> 或 <code>file:</code> URI 且过滤器未指定 URI，则 Intent 会通过测试的 URI 部分。换言之，如果过滤器只是列出 MIME 类型，则假定组件支持 <code>content:</code> 和 <code>file:</code> 数据。<blockquote><p>如果 Intent 指定 URI 或 MIME 类型，则数据测试会在 <intent-filter> 中没有 <code>&lt;data&gt;</code> 元素时失败。</p></blockquote></li></ol><h2 id="通用Intent"><a href="#通用Intent" class="headerlink" title="通用Intent"></a>通用Intent</h2><ul><li><a href="https://developer.android.com/guide/components/intents-common#Clock" target="_blank" rel="noopener">闹钟——创建闹铃、创建定时器、显示所有闹铃</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Calendar" target="_blank" rel="noopener">日历——添加日历事件</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Camera" target="_blank" rel="noopener">相机——拍摄相机或视频并将其返回、以静态图像模式启动相机应用、以视频模式启动相机应用</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Contacts" target="_blank" rel="noopener">联系人/人员应用——选择联系人、选择特定联系人数据、查看联系人、编辑现有联系人、插入联系人</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Email" target="_blank" rel="noopener">电子邮件——撰写带有可选附件的电子邮件</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Storage" target="_blank" rel="noopener">文件存储——检索、打开特定类型的文件</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Local" target="_blank" rel="noopener">本地操作-叫车？</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Maps" target="_blank" rel="noopener">地图——显示地图上的位置</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Music" target="_blank" rel="noopener">音乐和视频——播放媒体文件、基于搜索查询播放音乐</a></li><li><a href="https://developer.android.com/guide/components/intents-common#NewNote" target="_blank" rel="noopener">新笔记——创建笔记</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Phone" target="_blank" rel="noopener">电话——发起通话</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Search" target="_blank" rel="noopener">搜索——使用特定应用搜索、执行网页搜索</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Settings" target="_blank" rel="noopener">设置——打开特定设置部分</a> </li><li><a href="https://developer.android.com/guide/components/intents-common#Messaging" target="_blank" rel="noopener">发送短信</a></li><li><a href="https://developer.android.com/guide/components/intents-common#Browser" target="_blank" rel="noopener">网络浏览器——加载网址</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>官方文档摘录</tag>
      
      <tag>Intent</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Activity-Fragment</title>
    <link href="/2020/07/02/Activity-Fragment/"/>
    <url>/2020/07/02/Activity-Fragment/</url>
    
    <content type="html"><![CDATA[<h2 id="了解-Activity-生命周期"><a href="#了解-Activity-生命周期" class="headerlink" title="了解 Activity 生命周期"></a>了解 Activity 生命周期</h2><p><img src="https://note.youdao.com/yws/public/resource/0531bcaeb2b2b8c198255b5ad928981c/xmlnote/B9347B8B85F64476B768B1D827E3D0E2/47?ynotemdtimestamp=1593655869498" srcset="/img/loading.gif" alt="Activity 生命周期的简化图示"></p><h3 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h3><p>系统首次创建 Activity 时触发，在此方法中，需执行基本应用启动逻辑（声明界面、定义成员变量、配置某些界面），该逻辑在 Activity 的整个生命周期中只应发生一次。可以在此方法中<strong>将数据绑定到列表、将 Activity 与 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a> 相关联、实例化某些类范围变量</strong>。</p><h3 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h3><p>调用此方法使 Activity 对用户可见，为 Activity 进入前台并支持交互做准备。例如，应用此方法来<strong>初始化维护界面的代码</strong>。Activity不会一直处于“已开始”状态，一旦此回调结束，Activity便会进入“已恢复”状态，系统将调用onResume()方法。</p><h3 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h3><p>应用与用户交互的状态，用户会一直保持这种状态，直到某些事件发生，让焦点远离应用。当发生中断事件时，Activity进入“已暂停”状态，系统调用 onPause() 回调。如果Activity从“已暂停”状态返回“已恢复”状态，系统将再次调用 onResume() 方法。</p><h3 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h3><p>系统将此方法视为用户正在离开 Activity 的第一个标志（尽管这并不总是意味着活动正在遭到销毁）；此方法表示 Activity 不再位于前台（尽管如果用户处于多窗口模式，Activity 仍然可见）。使用 onPause() 方法暂时或调整当 Activity 处于“已暂停”状态时不应继续（或应有节制地继续）的操作，以及希望很快恢复的操作。Activity 进入此状态有多个原因，例如：</p><ul><li>如 onResume() 部分所述，某个事件会中断应用执行。这是最常见的情况。</li><li>在 Android7.0(API级别24)或更高版本中，有多个应用在多窗口模式下运行。无论何时，都只有一个应用（窗口）可以拥有焦点，因此系统会暂停所有其它应用。</li><li>有新的半透明 Activity（例如对话框）处于开启状态。只要 Activity 仍然部分可见但并未处于焦点之中，它便会一直暂停  </li></ul><p>还可以在此方法中<strong>释放系统资源、传感器（如GPS）手柄，或当 Activity 暂停且用户不需要它们时仍然可能影响电池续航时间的任何资源</strong>。<br>如果处于多窗口模式，则“已暂停”的 Activity 仍完全可见。因此，应考虑使用 onStop() 而非 onPause() 来完全释放或调整与界面相关的资源和操作，以便更好地支持多窗模式。<br>onPause() 执行非常简单，而且不一定要有足够的时间来执行保存操作。因此，<strong>不应该使用 onPause() 来保存应用或用户数据、进行网络调用或执行数据库事务。因为在该方法完成之前，此类工作可能无法完成。相反，应在 onStop() 期间执行高负载的关闭操作。</strong></p><h3 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h3><p>如果Activity对用户不可见，则说明其进入“已停止状态”，此时系统将会调用onStop()回调。在 onStop() 方法中，<strong>应用应释放或调整应用对用户不可见时的无用资源</strong>。例如，应用可以暂停动画效果，或从细粒度位置更新切换到粗粒度位置更新。<br>当 Activity 进入“已停止”状态时，Activity 对象会继续驻留在内存中：该对象将维护所有状态和成员信息，但不会附加到窗口管理器。状态恢复后，Activity 会重新调用这些信息。无需重新初始化在回调方法导致 Activity 进入“已恢复”状态期间创建的组件。<strong>系统还会追踪布局中每个View对象的当前状态</strong>，如果用户在 EditText 微件中输入文本，系统将保留文本内容，因此无需保存和恢复文本。  </p><h3 id="onDestory"><a href="#onDestory" class="headerlink" title="onDestory()"></a>onDestory()</h3><p>销毁 Ativity 之前，系统会先调用 onDestroy()。系统调用此回调的原因如下：</p><ul><li>Activity 正在结束（由于用户彻底关闭 Activity 或由于系统为 Activity 调用 finish()）。</li><li>由于配置变更（例如设备旋转或多窗口模式），系统暂时销毁 Activity。</li></ul><p>可以使用 <a href="https://developer.android.com/reference/android/app/Activity#isFinishing()" target="_blank" rel="noopener">isFinishing()</a> 方法区分这两种情况。<br>应使用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel" target="_blank" rel="noopener">ViewModel</a> 对象来容纳 Activity 的相关视图数据，如果由于配置变更而重新创建 Activity，则 ViewMode 不必执行任何操作，因为系统将保留 ViewModel 并将其提供给下一个 Activity 实例。如果不重新创建 Activity，ViewModel 将调用 <a href="https://developer.android.com/reference/androidx/lifecycle/ViewModel#onCleared()" target="_blank" rel="noopener">onCleared()</a> 方法，以便在 Activity 遭到销毁前清除所需的任何数据。<br>onDestory() 回调前应释放先前的回调（如onStop()）尚未释放的所有资源。</p><h2 id="Activity-状态和从内存中弹出"><a href="#Activity-状态和从内存中弹出" class="headerlink" title="Activity 状态和从内存中弹出"></a>Activity 状态和从内存中弹出</h2><table><thead><tr><th>系统终止进程的可能性</th><th>进程状态</th><th>Activity状态</th></tr></thead><tbody><tr><td>小</td><td>前台（拥有或即将获得焦点）</td><td>已创建 已开始 已恢复</td></tr><tr><td>中</td><td>后台（失去焦点）</td><td>已暂停</td></tr><tr><td>大</td><td>后台（不可见）</td><td>已停止</td></tr><tr><td></td><td>空</td><td>已销毁</td></tr><tr><td>表1.进程生命周期和Activity状态之间的关系</td><td></td><td></td></tr></tbody></table><h3 id="使用-onSaveInstanceState-保存简单轻量的界面状态"><a href="#使用-onSaveInstanceState-保存简单轻量的界面状态" class="headerlink" title="使用 onSaveInstanceState() 保存简单轻量的界面状态"></a>使用 onSaveInstanceState() 保存简单轻量的界面状态</h3><p>当 Activity 开始停止时，系统会调用 onSaveInstanceState() 方法，以便 Activity 可以将状态信息保存到实例状态 Bundle 中。此方法的默认实现保存有关 Activity 视图层次结构状态的瞬态信息，例如 EditText 微件中的文本或 ListView 微件的滚动位置。<br>如要保存持久化数据（例如用户首选项或数据库中的数据），应在 Activity 位于前台时抓住合适机会。如果没有这样的时机，应在执行 onStop() 方法期间保存此类数据。  </p><h3 id="使用保存的实例状态恢复-Activity-界面状态"><a href="#使用保存的实例状态恢复-Activity-界面状态" class="headerlink" title="使用保存的实例状态恢复 Activity 界面状态"></a>使用保存的实例状态恢复 Activity 界面状态</h3><ul><li>无论系统是新建 Activity 实例还是重新创建之前的实例，都会调用 onCreate() 方法，所以在尝试读取之前，必须检查状态 Bundle 是否为 null。如果为 null，系统将新建 Activity 实例，而不会恢复之前销毁的实例。</li><li>选择实现系统在 onStart() 方法之后调用的 onRestoreInstanceState()，而不是在 onCreate() 期间恢复状态。仅当存在要恢复的已保存状态时，系统才会调用 onRestoreInstanceState()，因此无需检查 Bundle 是否为 null。</li></ul><h3 id="ActivityA-启动-ActivityB-时"><a href="#ActivityA-启动-ActivityB-时" class="headerlink" title="ActivityA 启动 ActivityB 时"></a>ActivityA 启动 ActivityB 时</h3><ol><li>ActivityA 的 onPause() 方法执行。  </li><li>ActivityB 的 onCreate()、onStart() 和 onResume() 方法依次执行。（ActivityB 现在具有用户焦点。）  </li><li>然后，如果 ActivityA 在屏幕上不再可见，则其 onStop() 方法执行。<h2 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a>启动模式</h2><h3 id="使用清单文件设置（launchMode-属性）"><a href="#使用清单文件设置（launchMode-属性）" class="headerlink" title="使用清单文件设置（launchMode 属性）"></a>使用清单文件设置（launchMode 属性）</h3><code>&quot;standard&quot;</code> <strong>（默认模式）</strong>  <blockquote><p>默认值。系统在启动该 Activity 的任务中创建 Activty 的新实例，并将 intent 传送给该实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例。 </p></blockquote></li></ol><p><code>&quot;singleTop&quot;</code>  </p><blockquote><p>如果当前任务的顶部已存在 Activity 的实例，则系统会通过其 onNewIntent() 方法来将 intent 传递给该实例，而不是创建 Activity 的新实例。Activity 可以多次实例化，每个实例可以属于不同的任务，一个任务可以拥有多个实例（前提是返回堆栈顶部的 Activity 不是该 Activity 的现有实例）。  </p></blockquote><p><code>&quot;singleTask&quot;</code>  </p><blockquote><p>系统会创建新任务，并实例化新任务的根 Activity。但是，如果另外的任务中已存在该 Activity 的实例，则系统会通过调用其 onNewIntent() 方法将 intent 转送到该现有实例，而不是创建新实例。<strong>Activity 一次只能有一个实例存在。</strong>   </p></blockquote><p><code>&quot;singleInstance&quot;</code>  </p><blockquote><p>与 <code>&quot;singleTask&quot;</code> 相似，唯一不同的是系统不会将任何其他 Activity 启动到包含该实例的任务中。<strong>该 Activity 始终是其任务唯一的成员；</strong>由该 Activity 启动的任何 Activity 都会在其他的任务中打开。</p></blockquote><h3 id="使用Intent标记"><a href="#使用Intent标记" class="headerlink" title="使用Intent标记"></a>使用Intent标记</h3><p><code>FLAG_ACTIVITY_NEW_TASK</code>  </p><blockquote><p>在新任务中启动 Activity。如果现在启动的 Activity 已经有任务在运行，则系统会将该任务转到前台并恢复其最后的状态，而 Activity 将在 <code>onNewIntent()</code> 中收到新的 intent。此与 <code>&quot;singleTask&quot;</code> 产生的行为相同。</p></blockquote><p><code>FLAG_ACTIVITY_SINGLE_TOP</code>  </p><blockquote><p>如果要启动的 Activity 是当前 Activity（即位于返回堆栈顶部的 Activity），则现有实例会收到对 <code>onNewIntent()</code> 的调用，而不会创建 Activity 的新实例。此与 <code>&quot;singleTop&quot;</code> 产生的行为相同。</p></blockquote><p><code>FLAG_ACTIVITY_CLEAR_TOP</code>  </p><blockquote><p>如果要启动的 Activity 已经在当前任务中运行，则不会启动该 Activity 的新实例，而是会销毁位于它之上的所有其他 Activity，并通过 <code>onNewIntent()</code> 将此 intent 传送给它的已恢复实例（现在位于堆栈顶部）。</p></blockquote><p><code>FLAG_ACTIVITY_CLEAR_TOP</code> 最常与 <code>FLAG_ACTIVITY_NEW_TASK</code> 结合使用。将这两个标记结合使用，可以查找其他任务中的现有 Activity，并将其置于能够相应 intent 的位置。</p><h2 id="处理亲和性"><a href="#处理亲和性" class="headerlink" title="处理亲和性"></a>处理亲和性</h2><p><a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#Affinities" target="_blank" rel="noopener">处理亲和性</a> “亲和性”表示 Activity 倾向于属于哪个任务。默认情况下，同一应用中的所有 Activity 彼此具有亲和性。因此，在默认情况下，同一应用中的所有 Activity 都倾向于位于同一任务。不过，您可以修改 Activity 的默认亲和性。在不同应用中定义的 Activity 可以具有相同的亲和性，或者在同一应用中定义的 Activity 也可以被指定不同的任务亲和性。</p><h2 id="清除返回堆栈"><a href="#清除返回堆栈" class="headerlink" title="清除返回堆栈"></a>清除返回堆栈</h2><p><a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack#Clearing" target="_blank" rel="noopener">清除返回堆栈</a> 如果用户离开任务较长时间，系统会清除任务中除根 Activity 以外的所有 Activity。当用户再次返回到该任务时，只有根 Activity 会恢复。系统之所以采取这种行为方式是因为，经过一段时间后，用户可能已经放弃了之前执行的操作，现在返回任务是为了开始某项新的操作。</p><h2 id="在进程之间发送数据"><a href="#在进程之间发送数据" class="headerlink" title="在进程之间发送数据"></a>在进程之间发送数据</h2><p>Binder 事务缓冲区的大小固定有限，目前为 1MB，由进程中正在处理的所有事务共享。由于此限制是进程级别而不是 Activity 级别的限制，因此这些事务包括应用中的所有 binder 事务，例如 onSaveInstanceState，startActivity 以及与系统的任何互动。超过大小限制时，将引发 TransactionTooLargeException。  </p><p>对于 savedInstanceState 的具体情况，应将数据量保持在较小的规模，因为只要用户可以返回到该 Activity，系统进程就需要保留所提供的数据（即使 Activity 的进程已终止）。我们建议您将保存的状态保持在 50k 数据以下。  </p><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><pre><code class="hljs pf">FragmentManager <span class="hljs-keyword">fragment</span>Manager = getSupportFragmentManager();FragmentTransaction <span class="hljs-keyword">fragment</span>Transaction = <span class="hljs-keyword">fragment</span>Manager.beginTransaction();</code></pre><h2 id="add"><a href="#add" class="headerlink" title="add()"></a>add()</h2><pre><code class="hljs pf">ExampleFragment <span class="hljs-keyword">fragment</span> = new ExampleFragment();<span class="hljs-keyword">fragment</span>Transaction.add(R.id.fragment_container, <span class="hljs-keyword">fragment</span>);<span class="hljs-keyword">fragment</span>Transaction.commit();</code></pre><h2 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h2><pre><code class="hljs pgsql">// <span class="hljs-keyword">Create</span> <span class="hljs-built_in">new</span> fragment <span class="hljs-keyword">and</span> <span class="hljs-keyword">transaction</span>Fragment newFragment = <span class="hljs-built_in">new</span> ExampleFragment();FragmentTransaction <span class="hljs-keyword">transaction</span> = getSupportFragmentManager().beginTransaction();// Replace whatever <span class="hljs-keyword">is</span> <span class="hljs-keyword">in</span> the fragment_container <span class="hljs-keyword">view</span> <span class="hljs-keyword">with</span> this fragment,// <span class="hljs-keyword">and</span> <span class="hljs-keyword">add</span> the <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">to</span> the back stack<span class="hljs-keyword">transaction</span>.replace(R.id.fragment_container, newFragment);<span class="hljs-keyword">transaction</span>.addToBackStack(<span class="hljs-keyword">null</span>);// <span class="hljs-keyword">Commit</span> the <span class="hljs-keyword">transaction</span><span class="hljs-keyword">transaction</span>.<span class="hljs-keyword">commit</span>();</code></pre>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>官方文档摘录</tag>
      
      <tag>Activity</tag>
      
      <tag>Fragment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android Resource</title>
    <link href="/2020/07/02/Android-Resource/"/>
    <url>/2020/07/02/Android-Resource/</url>
    
    <content type="html"><![CDATA[<h2 id="创建别名资源"><a href="#创建别名资源" class="headerlink" title="创建别名资源"></a>创建别名资源</h2><h3 id="绘制对象"><a href="#绘制对象" class="headerlink" title="绘制对象"></a>绘制对象</h3><p>如要创建指向现有可绘制对象的别名，请使用 <code>&lt;drawable&gt;</code> 元素。例如：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">drawable</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"icon"</span>&gt;</span>@drawable/icon_ca<span class="hljs-tag">&lt;/<span class="hljs-name">drawable</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p>布局如要创建指向现有布局的别名，请使用包装在 <code>&lt;merge&gt;</code> 中的 <code>&lt;include&gt;</code> 元素。例如：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">merge</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">layout</span>=<span class="hljs-string">"@layout/main_ltr"</span>/&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">merge</span>&gt;</span></code></pre><h3 id="字符串和其他简单值"><a href="#字符串和其他简单值" class="headerlink" title="字符串和其他简单值"></a>字符串和其他简单值</h3><p>如要创建指向现有字符串的别名，您只需将所需字符串的资源 ID 用作新字符串的值。例如：</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hello"</span>&gt;</span>Hello<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"hi"</span>&gt;</span>@string/hello<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"red"</span>&gt;</span>#f00<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"highlight"</span>&gt;</span>@color/red<span class="hljs-tag">&lt;/<span class="hljs-name">color</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span></code></pre><h2 id="提供备用资源"><a href="#提供备用资源" class="headerlink" title="提供备用资源"></a>提供备用资源</h2><p><a href="https://developer.android.com/guide/topics/resources/providing-resources#AlternativeResources" target="_blank" rel="noopener">提供备用资源</a><br>几乎每个应用都应提供备用资源，以便支持特定的设备配置。例如，对于不同的屏幕密度和语言，您应分别加入备用可绘制对象资源和备用字符串资源。在运行时，Android 会检测当前设备配置并为应用加载合适的资源。</p><h2 id="res-目录中支持的资源目录"><a href="#res-目录中支持的资源目录" class="headerlink" title="res/目录中支持的资源目录"></a>res/目录中支持的资源目录</h2><p><a href="https://developer.android.com/guide/topics/resources/providing-resources#ResourceTypes" target="_blank" rel="noopener">res/目录中支持的资源目录</a></p><h2 id="AssetManager-访问原始文件"><a href="#AssetManager-访问原始文件" class="headerlink" title="AssetManager,访问原始文件"></a>AssetManager,访问原始文件</h2><p><a href="https://developer.android.com/reference/android/content/res/AssetManager" target="_blank" rel="noopener">AssetManager,访问原始文件</a></p><h2 id="内嵌复杂的-XML-资源"><a href="#内嵌复杂的-XML-资源" class="headerlink" title="内嵌复杂的 XML 资源"></a>内嵌复杂的 XML 资源</h2><p><a href="https://developer.android.com/guide/topics/resources/complex-xml-resources" target="_blank" rel="noopener">内嵌复杂的 XML 资源</a><br>某些资源类型是由 XML 文件表示的多个复杂资源合成的。例如动画矢量可绘制对象就是封装矢量可绘制对象和动画的可绘制资源。这需要使用至少 3 个 XML 文件。使用 AAPT 的内嵌资源格式，您可以在同一 XML 文件中定义所有三种资源。由于我们正在合成一个动画矢量可绘制对象，因此我们将该文件放在 <code>res/drawable/</code> 下。</p><h2 id="颜色状态列表"><a href="#颜色状态列表" class="headerlink" title="颜色状态列表"></a>颜色状态列表</h2><p><a href="https://developer.android.com/guide/topics/resources/color-list-resource" target="_blank" rel="noopener">颜色状态列表</a><br>主要是此页下的几个关于控件不同状态的布尔值。</p><h2 id="定义位图的重力-android-gravity"><a href="#定义位图的重力-android-gravity" class="headerlink" title="定义位图的重力 android:gravity"></a>定义位图的重力 android:gravity</h2><p><a href="https://developer.android.com/guide/topics/resources/drawable-resource" target="_blank" rel="noopener">定义位图的重力 android:gravity</a><br>（其下的一张表格）定义位图的重力。重力指示当位图小于容器时，可绘制对象在其容器中放置的位置。</p>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>官方文档摘录</tag>
      
      <tag>资源</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓导航组件</title>
    <link href="/2020/07/02/%E5%AE%89%E5%8D%93%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6/"/>
    <url>/2020/07/02/%E5%AE%89%E5%8D%93%E5%AF%BC%E8%88%AA%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>导航组件由以下三个关键部分组成：</p><ul><li>导航图 res/navigation/ 目录下文件  </li><li><code>NavHost</code>：显示导航图中目标的空白容器。导航组件包含一个默认 <code>NavHost</code> 实现(<code>NavHostFragment</code>)，可显示 Fragment 目标。</li><li><code>NavController</code>：在 <code>NavHost</code> 中管理应用导航的对象。当用户在整个应用中移动时，<code>NavController</code> 会安排 <code>NavHost</code> 中目标内容的交换。  </li></ul><h2 id="创建导航图"><a href="#创建导航图" class="headerlink" title="创建导航图"></a>创建导航图</h2><p>导航图是一种资源文件，其中包含所有目的地和操作。该图表会显示应用的所有导航路径。<br>要向项目添加导航图，请执行以下操作：</p><ol><li>在 “Project” 窗口中，右键点击 <code>res</code> 目录，然后依次选择 <strong>New &gt; Android Resource File</strong>。此时系统会显示 <strong>New Resource File</strong> 对话框。</li><li>在 <strong>File name</strong> 字段中输入名称，例如 “nav_graph”。</li><li>从 <strong>Resource type</strong> 下拉列表中选择 Navigation，然后点击 OK。 </li></ol><p>当您添加首个导航图时，Android Studio 会在 <code>res</code> 目录内创建一个 <code>navigation</code> 资源目录。该目录包含您的导航图资源文件（例如 <code>nav_graph.xml</code>）。</p><h2 id="向Activity添加NavHost"><a href="#向Activity添加NavHost" class="headerlink" title="向Activity添加NavHost"></a>向Activity添加NavHost</h2><h3 id="通过XML添加NavHostFragment"><a href="#通过XML添加NavHostFragment" class="headerlink" title="通过XML添加NavHostFragment"></a>通过XML添加NavHostFragment</h3><pre><code class="hljs django"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">android.support.constraint.ConstraintLayout</span></span></span><span class="xml">    xmlns:android="http://schemas.android.com/apk/res/android"</span><span class="xml">    xmlns:app="http://schemas.android.com/apk/res-auto"</span><span class="xml">    xmlns:tools="http://schemas.android.com/tools"</span><span class="xml">    android:layout_width="match_parent"</span><span class="xml">    android:layout_height="match_parent"</span><span class="xml">    tools:context=".MainActivity"&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">androidx.appcompat.widget.Toolbar</span></span></span><span class="xml">        .../&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span></span><span class="xml">        android:id="@+id/nav_host_fragment"</span><span class="xml">        <span class="hljs-comment">&lt;!-- NavHost实现的类名称 --&gt;</span></span><span class="xml">        android:name="androidx.navigation.fragment.NavHostFragment"</span><span class="xml">        android:layout_width="0dp"</span><span class="xml">        android:layout_height="0dp"</span><span class="xml">        app:layout_constraintLeft_toLeftOf="parent"</span><span class="xml">        app:layout_constraintRight_toRightOf="parent"</span><span class="xml">        app:layout_constraintTop_toTopOf="parent"</span><span class="xml">        app:layout_constraintBottom_toBottomOf="parent"</span><span class="xml">        <span class="hljs-comment">&lt;!-- 确保NavHostFragment会拦截系统返回按钮。只能有一个默认NavHost。如果同一布局中有多个主机，务必仅指定一个默认NavHost。 --&gt;</span></span><span class="xml">        app:defaultNavHost="true"</span><span class="xml">        <span class="hljs-comment">&lt;!-- 将NavHostFrament与导航图相关联。导航图会在此NavHostFragment中指定用户可以导航到的所有目的地。</span></span><span class="xml">        app:navGraph="@navigation/nav_graph" /&gt;</span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">com.google.android.material.bottomnavigation.BottomNavigationView</span></span></span><span class="xml">        .../&gt;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">android.support.constraint.ConstraintLayout</span>&gt;</span></span></code></pre><h3 id="使用-Layout-Editor-向-Activity-添加-NavHostFragment"><a href="#使用-Layout-Editor-向-Activity-添加-NavHostFragment" class="headerlink" title="使用 Layout Editor 向 Activity 添加 NavHostFragment"></a>使用 Layout Editor 向 Activity 添加 NavHostFragment</h3><ol><li>在项目文件列表中，双击 Activity 的布局 XML 文件，以在 Layout Editor 中将其打开。</li><li>在 <strong>Palette</strong> 窗格内，选择 Containers 类别。</li><li>将 NavHostFragment 视图拖动到 Activity 上。</li><li>在随即显示的 <strong>Navigation Graphs</strong> 对话框中，选择要与此 <code>NavHostFragment</code> 相关联的对应导航图，然后点击 OK。</li></ol><h2 id="将某个屏幕指定为起始目的地"><a href="#将某个屏幕指定为起始目的地" class="headerlink" title="将某个屏幕指定为起始目的地"></a>将某个屏幕指定为起始目的地</h2><ol><li>在 <strong>Design</strong> 标签页中，点击相应目的地，使其突出显示。</li><li>点击 <strong>Assign start destination</strong>（小房子） 按钮 。或者，您可以右键点击该目的地，然后点击 <strong>Set as Start Destination</strong>。</li></ol><h2 id="设计导航图"><a href="#设计导航图" class="headerlink" title="设计导航图"></a>设计导航图</h2><ul><li><a href="https://developer.android.com/guide/navigation/navigation-design-graph#top-level_navigation_graph" target="_blank" rel="noopener">顶级导航图</a></li><li><a href="https://developer.android.com/guide/navigation/navigation-design-graph#navigation_across_library_modules" target="_blank" rel="noopener">在库模块中导航</a></li></ul><h3 id="嵌套图表"><a href="#嵌套图表" class="headerlink" title="嵌套图表"></a>嵌套图表</h3><p>要将目的地归入一个嵌套图表中，操作如下：  </p><ol><li>在 Navigation Editor 中，按住 <code>shift</code> 键，然后点击想要添加到嵌套图表中的目的地。</li><li>右键单击以打开上下文菜单，然后依次选择 <strong>Move to Nested Graph &gt; New Graph</strong>。目的地包含在嵌套图表中。  </li></ol><p>在代码中，传递将根图连接到嵌套图表的操作的操作的资源ID：</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">view</span>)</span>.navigate(ID);</code></pre><h4 id="通过-引用其他导航图表"><a href="#通过-引用其他导航图表" class="headerlink" title="通过  引用其他导航图表"></a>通过 <include> 引用其他导航图表</h4><pre><code class="hljs stata">&lt;<span class="hljs-keyword">include</span> <span class="hljs-keyword">app</span>:<span class="hljs-keyword">graph</span>=<span class="hljs-string">"@navigation/included_graph"</span> /&gt;</code></pre><h3 id="全局操作"><a href="#全局操作" class="headerlink" title="全局操作"></a>全局操作</h3><p>对于应用中的任何可通过多条路径到达的目的地，您都应定义可转到它的相应全局操作。全局操作可用于从任意位置导航到某目的地。 </p><h4 id="创建全局操作"><a href="#创建全局操作" class="headerlink" title="创建全局操作"></a>创建全局操作</h4><p>要创建全局操作，请执行以下操作：  </p><ol><li>在 <strong>Graph Editor</strong> 中，点击一个目的地，使其突出显示。</li><li>右键点击该目的地，以显示上下文菜单。</li><li>依次选择 <strong>Add Action &gt; Global</strong>。此时系统会在该目的地左侧显示一个箭头。  </li></ol><h2 id="导航到目的地"><a href="#导航到目的地" class="headerlink" title="导航到目的地"></a>导航到目的地</h2><p>导航到目的地是使用 <code>NavController</code> 完成的，后者是一个在 <code>NavHost</code> 中管理应用导航的对象。每个 <code>NavHost</code> 均有自己的相应 <code>NavController</code> 。可以使用以下方法之一检索 <code>NavController</code> ：<br><strong>Kotlin</strong>：</p><ul><li>Fragment.findNavController()</li><li>View.findNavController()</li><li>Activity.findNavController(viewId: Int)  </li></ul><p><strong>Java</strong>：</p><ul><li>NavHostFragment.findNavController(Fragment)</li><li>Navigation.findNavController(Activity, @IdRes int viewId)</li><li>Navigation.findNavController(View)  </li></ul><p>检索 <code>NavController</code> 之后，可以调用navigate()的某个重载，以在各个目的地之间导航。</p><h3 id="使用-ID-导航"><a href="#使用-ID-导航" class="headerlink" title="使用 ID 导航"></a>使用 ID 导航</h3><p>对于按钮，可以使用 Navigation 类的 createNavigateOnClickListener(ID) 导航到目的地。 </p><h4 id="为导航提供导航选项"><a href="#为导航提供导航选项" class="headerlink" title="为导航提供导航选项"></a>为导航提供导航选项</h4><p>在导航图中定义操作时，Navigation 会生成相应的 <code>NavAction</code> 类，其中包含为该操作定义的配置，包括如下内容：</p><ul><li>目的地：目标目的地的资源 ID。</li><li>默认参数：android.os.Bundle，包含目标目的地的默认值（如有提供）。</li><li>导航选项：导航选项，表示为 <code>NavOptions</code> 。此类包含从目标目的地往返的所有特殊配置，包括动画资源配置、弹出行为以及是否应在单一顶级模式下启动目的地。  </li></ul><h3 id="使用URI导航"><a href="#使用URI导航" class="headerlink" title="使用URI导航"></a>使用URI导航</h3><p>使用 URI 进行导航时，返回堆栈不会重置。这与其他深层链接导航不同，后者在导航时会替换返回堆栈。不过，<code>popUpTo</code> 和 <code>popUpToInclusive</code> 仍会从返回堆栈中移除目的地，就像您使用 ID 导航一样。</p><h3 id="导航和返回堆栈"><a href="#导航和返回堆栈" class="headerlink" title="导航和返回堆栈"></a>导航和返回堆栈</h3><p>每次调用 <a href="https://developer.android.com/reference/androidx/navigation/NavController#navigate(int)" target="_blank" rel="noopener"><code>navigate()</code></a> 方法都会将另一目的地放置到堆栈的顶部。点按<strong>向上</strong>或<strong>返回</strong>会分别调用 <a href="https://developer.android.com/reference/androidx/navigation/NavController#navigateUp()" target="_blank" rel="noopener"><code>NavController.navigateUp()</code></a> 和 <a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack()" target="_blank" rel="noopener"><code>NavController.popBackStack()</code></a> 方法，用于移除（或弹出）堆栈顶部的目的地。<br><code>NavController.popBackStack()</code> 会返回一个布尔值，表明它是否已成功返回到另一个目的地。当返回 <code>false</code> 时，最常见的情况是手动弹出导航表的起始目的地。<br>如果该方法返回 <code>false</code>，则 <code>NavController.getCurrentDestination()</code> 会返回 <code>null</code> 。此时应导航到新目的地，或通过对 Activity 调用 <code>finish()</code> 来处理弹出情况，如下例所示：</p><pre><code class="hljs less"><span class="hljs-selector-tag">if</span> (!navController.popBackStack()) &#123;    <span class="hljs-comment">// Call finish() on your Activity</span>    <span class="hljs-selector-tag">finish</span>();&#125;</code></pre><h3 id="popUpTo-和-popUpToInclusive"><a href="#popUpTo-和-popUpToInclusive" class="headerlink" title="popUpTo 和 popUpToInclusive"></a>popUpTo 和 popUpToInclusive</h3><p>使用操作进行导航时，可以选择从返回堆栈上弹出其他目的地。例如，如果应用具有初始登录流程，那么在用户登录后，应将所有与登录相关的目的地从返回堆栈上弹出，这样返回按钮就不会将用户带回登录流程。<br>要在从一个目的地导航到另一个目的地时弹出目的地，可以在关联的 <code>&lt;action&gt;</code> 元素中添加 <code>app:popUpTo</code> 属性。<code>app:popUpTo</code> 会告知 Navigation 库在调用 <code>navigate()</code> 的过程中从返回堆栈上弹出一些目的地。属性值是应保留在堆栈中的最新目的地的 ID。<br>还可以添加 <code>app:popUpToInclusive=&quot;true&quot;</code>，以表明在 <code>app:popUpTo</code> 中指定的目的地也应从返回堆栈中移除。<br><a href="https://developer.android.com/guide/navigation/navigation-navigate#pop" target="_blank" rel="noopener">示例</a>（有助于理解）。  </p><h3 id="条件导航"><a href="#条件导航" class="headerlink" title="条件导航"></a>条件导航</h3><p>在为应用设计导航时，可能需要基于条件逻辑将用户转到某一个目的地而非另一个。<a href="https://developer.android.com/guide/navigation/navigation-conditional" target="_blank" rel="noopener">例如，可能具有一些需要用户登录的目的地，或者可能在游戏中针对获胜或失败的玩家提供了不同的目的地。</a></p><h2 id="在目的地间传递数据"><a href="#在目的地间传递数据" class="headerlink" title="在目的地间传递数据"></a>在目的地间传递数据</h2><h3 id="定义目的地参数"><a href="#定义目的地参数" class="headerlink" title="定义目的地参数"></a>定义目的地参数</h3><p>要在目的地之间传递数据，首先按照以下步骤将参数添加到接收它的目的地来定义参数：  </p><ol><li>在 Navigation Editor 中，点击接收参数的目的地。  </li><li>在 <strong>Attributes</strong> 面板中点击 <strong>Arguments</strong> 处的 Add（+）。</li><li>在弹出的面板中输入 Name、Type、参数是否为 Array、参数是否可为 null（不论基础类型的 null 性如何，数组始终可为 null），以及 Default Value（若需要），然后点击 <strong>Add</strong>。  </li></ol><h3 id="使用-Safe-Args-传递安全的数据"><a href="#使用-Safe-Args-传递安全的数据" class="headerlink" title="使用 Safe Args 传递安全的数据"></a>使用 Safe Args 传递安全的数据</h3><p>要将Safe Args添加到项目，首先在顶级 <code>build gradle</code> 文件中包含以下 <code>classpath</code> ：</p><pre><code class="hljs gradle">    <span class="hljs-keyword">buildscript</span> &#123;        <span class="hljs-keyword">repositories</span> &#123;            google()        &#125;        <span class="hljs-keyword">dependencies</span> &#123;            <span class="hljs-keyword">def</span> nav_version = <span class="hljs-string">"2.3.0-alpha01"</span>            <span class="hljs-keyword">classpath</span> <span class="hljs-string">"androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version"</span>        &#125;    &#125;```  同时必须应用以下两个可用插件之一。  要生成适用于 Java 或 Java 和 Kotlin 混合模块的 Java 语言代码，请将以下行添加到应用或模块的 `build.gradle` 文件中：</code></pre><p>apply plugin: “androidx.navigation.safeargs”</p><pre><code class="hljs plain">此外，要生成适用于 Kotlin 独有的模块的 Kotlin 代码，请添加以下行：</code></pre><p>apply plugin: “androidx.navigation.safeargs.kotlin”</p><pre><code class="hljs clean">#### 将Safe Args用于全局操作将 Safe Args 用于全局操作时，必须为根 `&lt;navigation&gt;` 元素提供一个 `android:id` 值。Navigation会根据 `android:id` 值为 `&lt;navigation&gt;` 元素生成一个 `Directions` 类。### 使用Bundle对象在目的地之间传递参数传递</code></pre><pre><code>Bundle bundle = new Bundle();bundle.putString(&quot;amount&quot;, &quot;amount&quot;);Navigation.findNavController(view).navigate(ID, bundle);</code></pre><pre><code class="hljs plain">接收</code></pre><pre><code>String amount = getArguments().getString(&quot;amount&quot;);</code></pre><pre><code class="hljs markdown"><span class="hljs-section">### 将数据传递给起始目的地</span>您可以将数据传递给应用的起始目的地。首先，您必须显式构建一个 <span class="hljs-code">`Bundle`</span> 来存储数据。然后，使用以下方法之一将该 <span class="hljs-code">`Bundle`</span> 传递给起始目的地：  <span class="hljs-bullet">+ </span>如果您要以编程方式创建 <span class="hljs-code">`NavHost`</span>，请调用 <span class="hljs-code">`NavHostFragment.create(R.navigation.graph, args)`</span>，其中 args 是存储数据的 <span class="hljs-code">`Bundle`</span>。<span class="hljs-bullet">+ </span>或者，您也可以通过调用以下 <span class="hljs-code">`NavController.setGraph()`</span> 过载之一来设置起始目的地参数：<span class="hljs-bullet">    + </span>使用图表 ID：<span class="hljs-code">`navController.setGraph(R.navigation.graph, args)`</span><span class="hljs-bullet">    + </span>使用图表本身：<span class="hljs-code">`navController.setGraph(navGraph, args)`</span>  要检索起始目的地中的数据，请调用 <span class="hljs-code">`Fragment.getArguments()`</span>。  <span class="hljs-section">## 为目的地创建深层链接</span><span class="hljs-section">### 创建显示深层链接</span>当用户通过显式深层链接打开您的应用时，任务返回堆栈会被清除，并被替换为相应的深层链接目的地。当嵌套图表时，每个嵌套级别的起始目的地（即层次结构中每个 <span class="hljs-code">`&lt;navigation&gt;`</span> 元素的起始目的地）也会添加到相应堆栈中。也就是说，当用户从深层链接目的地按下返回按钮时，他们会返回到相应的导航堆栈，就像从入口点进入您的应用一样。  您可以使用 [<span class="hljs-string">`NavDeepLinkBuilder`</span>][<span class="hljs-symbol">8</span>] 类构建 [<span class="hljs-string">`PendingIntent`</span>][<span class="hljs-symbol">9</span>]，如下例所示。请注意，如果提供的上下文不是 <span class="hljs-code">`Activity`</span>，构造函数会使用 [<span class="hljs-string">`PackageManager.getLaunchIntentForPackage()`</span>][<span class="hljs-symbol">10</span>] 作为默认 Activity 来启动（如果有）。</code></pre><pre><code>PendingIntent pendingIntent = new NavDeepLinkBuilder(context)    .setGraph(R.navigation.nav_graph)    .setDestination(R.id.android)    .setArguments(args)    .createPendingIntent();</code></pre><pre><code class="hljs markdown">如果已有 <span class="hljs-code">`NavController`</span>，则还可以通过 [<span class="hljs-string">`NavController.createdDeepLink()`</span>][<span class="hljs-symbol">11</span>] 创建深层链接。<span class="hljs-section">### 创建隐式深层链接</span>[<span class="hljs-string">创建隐式深层链接</span>][<span class="hljs-symbol">12</span>]<span class="hljs-section">## 在目的地之间添加动画过渡效果</span>[<span class="hljs-string">在目的地之间添加动画过渡效果</span>][<span class="hljs-symbol">13</span>]<span class="hljs-section">## 使用NavigationUI更新界面组件</span><span class="hljs-section">### 监听导航事件</span><span class="hljs-code">`NavController`</span> 提供 <span class="hljs-code">`OnDestinationChangedListener()`</span> 接口，该接口在当前目的地或其参数发生更改时调用。可以通过 [<span class="hljs-string">`addOnDestinationChangedListener()`</span>][<span class="hljs-symbol">14</span>] 方法注册新监听器。  举例来说，使用此监听器可以在应用的一些区域显示常见界面元素，而在另外一些区域隐藏这些元素。</code></pre><pre><code>navController.addOnDestinationChangedListener(new NavController.OnDestinationChangedListener() {   @Override   public void onDestinationChanged(@NonNull NavController controller,           @NonNull NavDestination destination, @Nullable Bundle arguments) {       if(destination.getId() == R.id.full_screen_destination) {           toolbar.setVisibility(View.GONE);           bottomNavigationView.setVisibility(View.GONE);       } else {           toolbar.setVisibility(View.VISIBLE);           bottomNavigationView.setVisibility(View.VISIBLE);       }   }});</code></pre><pre><code class="hljs markdown"><span class="hljs-section">### 顶部应用栏</span><span class="hljs-section">#### AppBarConfiguration</span><span class="hljs-code">`NavigationUI`</span> 使用 [<span class="hljs-string">`AppBarConfiguration`</span>][<span class="hljs-symbol">15</span>] 对象管理在应用显示区域左上角的导航按钮行为。默认情况下，如果用户位于导航图的顶级目的地，则导航按钮会隐藏并且在任何其他目的地显示为向上按钮。  要将导航图的起始目的地用作唯一顶级目的地，可以创建 <span class="hljs-code">`AppBarConfiguration`</span> 对象并传入相应的导航图，如下所示：</code></pre><pre><code>AppBarConfiguration appBarConfiguration =        new AppBarConfiguration.Builder(navController.getGraph()).build();</code></pre><pre><code class="hljs plain">如果想自定义哪些目的地被视为顶级目的地，则可以改为将一组目的地ID传递给构造函数，如下所示：</code></pre><pre><code>AppBarConfiguration appBarConfiguration =        new AppBarConfiguration.Builder(R.id.main, R.id.android).build();</code></pre><pre><code class="hljs routeros"><span class="hljs-comment">#### 创建工具栏</span>1. 在主 Activity 中定义工具栏```            &lt;androidx.appcompat.widget.Toolbar        android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">"match_parent"</span>        android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">"wrap_content"</span>        android:<span class="hljs-attribute">id</span>=<span class="hljs-string">"@+id/tool_bar"</span>        tools:<span class="hljs-attribute">ignore</span>=<span class="hljs-string">"MissingConstraints"</span> /&gt;</code></pre><ol start="2"><li>通过 Activity 的 <code>onCreate()</code> 方法调用 <a href="https://developer.android.com/reference/androidx/navigation/ui/NavigationUI#setupWithNavController(android.support.v7.widget.Toolbar,%20androidx.navigation.NavController,%20androidx.navigation.ui.AppBarConfiguration)" target="_blank" rel="noopener"><code>setupWithNavController()</code></a><pre><code class="hljs reasonml">@Overrideprotected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;    ...    NavController navController = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">this</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_host_fragment</span>)</span>;    AppBarConfiguration appBarConfiguration =            <span class="hljs-keyword">new</span> AppBarConfiguration.<span class="hljs-constructor">Builder(<span class="hljs-params">navController</span>.<span class="hljs-params">getGraph</span>()</span>).build<span class="hljs-literal">()</span>;    Toolbar toolbar = find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">toolbar</span>)</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>setup<span class="hljs-constructor">WithNavController(<span class="hljs-params">toolbar</span>, <span class="hljs-params">navController</span>)</span>;&#125;</code></pre></li></ol><h5 id="包含-CollapsingToolbarLayout"><a href="#包含-CollapsingToolbarLayout" class="headerlink" title="包含 CollapsingToolbarLayout"></a>包含 CollapsingToolbarLayout</h5><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>setup<span class="hljs-constructor">WithNavController(<span class="hljs-params">layout</span>, <span class="hljs-params">toolbar</span>, <span class="hljs-params">navController</span>, <span class="hljs-params">appBarConfiguration</span>)</span>;</code></pre><h5 id="操作栏添加导航支持"><a href="#操作栏添加导航支持" class="headerlink" title="操作栏添加导航支持"></a>操作栏添加导航支持</h5><p>要向默认操作栏添加导航支持，可通过 Activity 的 <code>onCreate()</code> 方法调用 <a href="https://developer.android.com/reference/androidx/navigation/ui/NavigationUI#setupActionBarWithNavController(android.support.v7.app.AppCompatActivity,%20androidx.navigation.NavController,%20androidx.navigation.ui.AppBarConfiguration)" target="_blank" rel="noopener"><code>setupActionBarWithNavController()</code></a> 。</p><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>setup<span class="hljs-constructor">ActionBarWithNavController(<span class="hljs-params">this</span>, <span class="hljs-params">navController</span>, <span class="hljs-params">appBarConfiguration</span>)</span>;</code></pre><p>接着，替换 <code>onSupportNavigateUp()</code> 以处理向上导航：</p><pre><code class="hljs reasonml">@Overridepublic boolean on<span class="hljs-constructor">SupportNavigateUp()</span> &#123;    NavController navController = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">this</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_host_fragment</span>)</span>;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>navigate<span class="hljs-constructor">Up(<span class="hljs-params">navController</span>, <span class="hljs-params">appBarConfiguration</span>)</span><span class="hljs-operator">            || </span>super.on<span class="hljs-constructor">SupportNavigateUp()</span>;&#125;</code></pre><h3 id="添加抽屉式导航栏"><a href="#添加抽屉式导航栏" class="headerlink" title="添加抽屉式导航栏"></a>添加抽屉式导航栏</h3><p>抽屉式导航栏图标会显示在使用 <code>DrawerLayout</code> 的<strong>所有顶级目的地</strong>上。顶级目的地是应用的根级目的地。它们不会在应用栏中显示向上按钮。  </p><ol><li>声明 <code>DrawerLayout</code> 为根视图。</li><li>将 <code>DrawerLayout</code> 连接到导航图，具体方法是将其传递给 <code>AppBarConfiguration</code>，如下所示：<pre><code class="hljs reasonml">AppBarConfiguration appBarConfiguration =        <span class="hljs-keyword">new</span> AppBarConfiguration.<span class="hljs-constructor">Builder(<span class="hljs-params">navController</span>.<span class="hljs-params">getGraph</span>()</span>)            .set<span class="hljs-constructor">DrawerLayout(<span class="hljs-params">drawerLayout</span>)</span>            .build<span class="hljs-literal">()</span>;</code></pre></li><li>在主 Activity 类中，通过主 Activity 的 <code>onCreate()</code> 方法调用 <a href="https://developer.android.com/reference/androidx/navigation/ui/NavigationUI#setupWithNavController(android.support.v7.widget.Toolbar,%20androidx.navigation.NavController,%20androidx.navigation.ui.AppBarConfiguration)" target="_blank" rel="noopener"><code>setupWithNavController()</code></a>,如下所示：<pre><code class="hljs reasonml">@Overrideprotected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;    ...    NavController navController = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">this</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_host_fragment</span>)</span>;    NavigationView navView = find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_view</span>)</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>setup<span class="hljs-constructor">WithNavController(<span class="hljs-params">navView</span>, <span class="hljs-params">navController</span>)</span>;&#125;</code></pre></li></ol><h3 id="底部导航栏"><a href="#底部导航栏" class="headerlink" title="底部导航栏"></a>底部导航栏</h3><ol><li>在主 Activity 中定义底部导航栏。<pre><code class="hljs stylus">&lt;com<span class="hljs-selector-class">.google</span><span class="hljs-selector-class">.android</span><span class="hljs-selector-class">.material</span><span class="hljs-selector-class">.bottomnavigation</span>.BottomNavigationView    android:id=<span class="hljs-string">"@+id/bottom_nav"</span>    app:menu=<span class="hljs-string">"@menu/menu_bottom_nav"</span> /&gt;</code></pre></li><li>在主 Activity 类中，通过主 Activity 的 <code>onCreate()</code> 方法调用 <a href="https://developer.android.com/reference/androidx/navigation/ui/NavigationUI#setupWithNavController(android.support.v7.widget.Toolbar,%20androidx.navigation.NavController,%20androidx.navigation.ui.AppBarConfiguration)" target="_blank" rel="noopener"><code>setupWithNavController()</code></a> ,如下所示：<pre><code class="hljs reasonml">@Overrideprotected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;    ...    NavController navController = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">this</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_host_fragment</span>)</span>;    BottomNavigationView bottomNav = find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">bottom_nav</span>)</span>;    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>setup<span class="hljs-constructor">WithNavController(<span class="hljs-params">bottomNav</span>, <span class="hljs-params">navController</span>)</span>;&#125;</code></pre></li></ol><h3 id="将目的地（Fragment）关联到菜单项（MenuItem）"><a href="#将目的地（Fragment）关联到菜单项（MenuItem）" class="headerlink" title="将目的地（Fragment）关联到菜单项（MenuItem）"></a>将目的地（Fragment）关联到菜单项（MenuItem）</h3><p>如果 <code>MenuItem</code> 的 <code>id</code> 与目的地的 <code>id</code> 匹配，则 <code>NavController</code> 可以导航至该目的地。<br>菜单项</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">menu</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span>    ...    <span class="hljs-tag">&lt;<span class="hljs-name">item</span></span><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@id/details_page_fragment"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:icon</span>=<span class="hljs-string">"@drawable/ic_details"</span></span><span class="hljs-tag">        <span class="hljs-attr">android:title</span>=<span class="hljs-string">"@string/details"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span></code></pre><p>目的地</p><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">navigation</span> <span class="hljs-attr">xmlns:app</span>=<span class="hljs-string">"http://schemas.android.com/apk/res-auto"</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">"http://schemas.android.com/tools"</span></span><span class="hljs-tag">    <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span></span><span class="hljs-tag">    <span class="hljs-attr">...</span> &gt;</span>    ...    <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/details_page_fragment"</span></span><span class="hljs-tag">         <span class="hljs-attr">android:label</span>=<span class="hljs-string">"@string/details"</span></span><span class="hljs-tag">         <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.android.myapp.DetailsFragment"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">navigation</span>&gt;</span></code></pre><p>使用 <code>onOptionsItemSelected()</code> 替换Activity的 <code>onCreateOptionsMenu()</code> 以调用 <code>onNavDestinationSelected()</code> 将菜单项与目的地相关联，如下所示：</p><pre><code class="hljs reasonml">@Overridepublic boolean on<span class="hljs-constructor">OptionsItemSelected(MenuItem <span class="hljs-params">item</span>)</span> &#123;    NavController navController = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Navigation</span>.</span></span>find<span class="hljs-constructor">NavController(<span class="hljs-params">this</span>, R.<span class="hljs-params">id</span>.<span class="hljs-params">nav_host_fragment</span>)</span>;    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavigationUI</span>.</span></span>on<span class="hljs-constructor">NavDestinationSelected(<span class="hljs-params">item</span>, <span class="hljs-params">navController</span>)</span><span class="hljs-operator">            || </span>super.on<span class="hljs-constructor">OptionsItemSelected(<span class="hljs-params">item</span>)</span>;&#125;</code></pre><h2 id="使用-ViewPager-创建包含标签页的滑动视图"><a href="#使用-ViewPager-创建包含标签页的滑动视图" class="headerlink" title="使用 ViewPager 创建包含标签页的滑动视图"></a>使用 ViewPager 创建包含标签页的滑动视图</h2><p><a href="https://developer.android.com/guide/navigation/navigation-swipe-view" target="_blank" rel="noopener">示例链接</a></p><h2 id="以编程方式与导航组件交互"><a href="#以编程方式与导航组件交互" class="headerlink" title="以编程方式与导航组件交互"></a>以编程方式与导航组件交互</h2><pre><code class="hljs reasonml">NavHostFragment finalHost = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NavHostFragment</span>.</span></span>create(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>navigation.example_graph);get<span class="hljs-constructor">SupportFragmentManager()</span>.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Transaction()</span>    .replace(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>id.nav_host, finalHost)    .set<span class="hljs-constructor">PrimaryNavigationFragment(<span class="hljs-params">finalHost</span>)</span> <span class="hljs-comment">// this is the equivalent to app:defaultNavHost="true"</span>    .commit<span class="hljs-literal">()</span>;</code></pre><p>请注意，<code>setPrimaryNavigationFragment(finalHost)</code> 允许您的 <code>NavHost</code> 截获对系统“返回”按钮的按下操作。您也可以添加 <code>app:defaultNavHost=&quot;true&quot;</code>，在 <code>NavHost</code> XML 中实现此行为。如果要实现<a href="https://developer.android.com/guide/navigation/navigation-custom-back" target="_blank" rel="noopener">自定义“返回”按钮行为</a>，并且不希望 <code>NavHost</code> 截获对“返回”按钮的按下操作，您可以将 <code>null</code> 传递给 <code>setPrimaryNavigationFragment()</code>。</p>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>官方文档摘录</tag>
      
      <tag>导航组件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Retrofit使用</title>
    <link href="/2020/07/01/Retrofit/"/>
    <url>/2020/07/01/Retrofit/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Retrofit 是一个 RESTful 的 HTTP 网络请求框架的封装，网络请求的工作本质上是由 OkHttp 完成，而 Retrofit 仅负责网络请求接口的封装。</p><h4 id="1-添加-Retrofit-库的依赖"><a href="#1-添加-Retrofit-库的依赖" class="headerlink" title="1. 添加 Retrofit 库的依赖"></a>1. 添加 Retrofit 库的依赖</h4><pre><code class="hljs clean"><span class="hljs-comment">//    将Java版本设置为1.8*或更高版本。不然会报错(java.lang.NoSuchMethodError: No static method metafactory...）</span><span class="hljs-comment">//    在android下添加</span><span class="hljs-comment">//    compileOptions &#123;</span><span class="hljs-comment">//        sourceCompatibility JavaVersion.VERSION_1_8</span><span class="hljs-comment">//        targetCompatibility JavaVersion.VERSION_1_8</span><span class="hljs-comment">//    &#125;</span>    <span class="hljs-keyword">implementation</span> <span class="hljs-string">'com.squareup.retrofit2:retrofit:2.9.0'</span></code></pre><h4 id="2-添加-Converters"><a href="#2-添加-Converters" class="headerlink" title="2. 添加 Converters"></a>2. 添加 Converters</h4><pre><code class="hljs css"><span class="hljs-selector-tag">Gson</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-gson</span><span class="hljs-selector-tag">Jackson</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-jackson</span><span class="hljs-selector-tag">Moshi</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-moshi</span><span class="hljs-selector-tag">Protobuf</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-protobuf</span><span class="hljs-selector-tag">Wire</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-wire</span><span class="hljs-selector-tag">Simple</span> <span class="hljs-selector-tag">XML</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-simplexml</span><span class="hljs-selector-tag">JAXB</span>: <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-jaxb</span><span class="hljs-selector-tag">Scalars</span> (<span class="hljs-selector-tag">primitives</span>, <span class="hljs-selector-tag">boxed</span>, <span class="hljs-selector-tag">and</span> <span class="hljs-selector-tag">String</span>): <span class="hljs-selector-tag">com</span><span class="hljs-selector-class">.squareup</span><span class="hljs-selector-class">.retrofit2</span><span class="hljs-selector-pseudo">:converter-scalars</span></code></pre><h4 id="3-添加网络权限"><a href="#3-添加网络权限" class="headerlink" title="3. 添加网络权限"></a>3. 添加网络权限</h4><pre><code class="hljs routeros">&lt;uses-permission android:<span class="hljs-attribute">name</span>=<span class="hljs-string">"android.permission.INTERNET"</span>/&gt;</code></pre><h4 id="4-创建装载服务器返回数据的类"><a href="#4-创建装载服务器返回数据的类" class="headerlink" title="4. 创建装载服务器返回数据的类"></a>4. 创建装载服务器返回数据的类</h4><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ResultData</span> &#123;    ...    <span class="hljs-comment">// 根据返回数据的格式和数据解析方式（Json、XML等）定义</span>    &#125;</code></pre><h4 id="5-创建用于配置网络请求的接口"><a href="#5-创建用于配置网络请求的接口" class="headerlink" title="5. 创建用于配置网络请求的接口"></a>5. 创建用于配置网络请求的接口</h4><p>Retrofit 将 Http 请求抽象成 Java 接口，采用<strong>注解</strong>描述网络请求参数和配置网络请求参数</p><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>IGetRequest &#123;        @<span class="hljs-builtin-name">GET</span>(<span class="hljs-string">"openapi.do?keyfrom=Yanzhikai&amp;key=2032414398&amp;type=data&amp;doctype=json&amp;version=1.1&amp;q=car"</span>)    Call&lt;ResultData&gt;  getCall();&#125;</code></pre><p><strong>注解说明</strong><br>    + 网络请求方法：@GET、@POST、@PUT、@DELETE、@HEAD（常用）<br>    + 网络请求标记：@FormUrlEncoded、@Multipart、@Streaming<br>    + 网络请求参数：@Header &amp; @Headers、@Body、@Field、@FieldMap、@Part、@PartMap、@Query、@QueryMap、@Path、@Url<br>    详细解释见如下<a href="https://www.jianshu.com/p/a3e162261ab6" target="_blank" rel="noopener">博文链接</a>  </p><h4 id="6-创建-Retrofit-实例"><a href="#6-创建-Retrofit-实例" class="headerlink" title="6. 创建 Retrofit 实例"></a>6. 创建 Retrofit 实例</h4><pre><code class="hljs reasonml">Retrofit retrofit = <span class="hljs-keyword">new</span> Retrofit.<span class="hljs-constructor">Builder()</span>                    .base<span class="hljs-constructor">Url(Url)</span>                    .add<span class="hljs-constructor">ConverterFactory(GsonConverterFactory.<span class="hljs-params">create</span>()</span>)                    .build<span class="hljs-literal">()</span></code></pre><h4 id="7-创建网络请求接口实例"><a href="#7-创建网络请求接口实例" class="headerlink" title="7. 创建网络请求接口实例"></a>7. 创建网络请求接口实例</h4><pre><code class="hljs gcode"><span class="hljs-comment">// 创建网络请求接口的实例</span>IGetRequest request = retrofit.create<span class="hljs-comment">(IGetRequest.class)</span>;<span class="hljs-comment">// 对发送请求进行封装</span><span class="hljs-keyword">Call</span>&lt;ResultData&gt; <span class="hljs-keyword">call</span> = request.getCall<span class="hljs-comment">()</span>;</code></pre><h4 id="8-发送网络请求（异步-or-同步），-and-处理"><a href="#8-发送网络请求（异步-or-同步），-and-处理" class="headerlink" title="8. 发送网络请求（异步 or 同步）， and 处理"></a>8. 发送网络请求（异步 or 同步）， and 处理</h4><pre><code class="hljs gradle"><span class="hljs-comment">//发送网络请求(异步)</span><span class="hljs-keyword">call</span>.enqueue(<span class="hljs-keyword">new</span> Callback&lt;ResultData&gt;() &#123;    <span class="hljs-comment">//请求成功时回调</span>    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onResponse(<span class="hljs-keyword">Call</span>&lt;ResultData&gt; <span class="hljs-keyword">call</span>, Response&lt;ResultData&gt; response) &#123;        <span class="hljs-comment">//处理结果</span>    &#125;    <span class="hljs-comment">//请求失败时候的回调</span>    @Override    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onFailure(<span class="hljs-keyword">Call</span>&lt;ResultData&gt; <span class="hljs-keyword">call</span>, Throwable throwable) &#123;        <span class="hljs-comment">//提示失败</span>    &#125;&#125;);<span class="hljs-comment">// 发送网络请求（同步）</span>Response&lt;ResultData&gt; response = <span class="hljs-keyword">call</span>.execute();</code></pre>]]></content>
    
    
    <categories>
      
      <category>安卓</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开源库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown语法</title>
    <link href="/2020/07/01/Markdown%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/07/01/Markdown%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="来看看MarDown语法"><a href="#来看看MarDown语法" class="headerlink" title="来看看MarDown语法"></a>来看看MarDown语法</h1><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="调出vscode-MarkDown预览框"><a href="#调出vscode-MarkDown预览框" class="headerlink" title="调出vscode MarkDown预览框"></a>调出vscode MarkDown预览框</h1><h3 id="1-Crtl-shift-p-输入Markdown"><a href="#1-Crtl-shift-p-输入Markdown" class="headerlink" title="1.Crtl+shift+p,输入Markdown"></a>1.Crtl+shift+p,输入Markdown</h3><h3 id="2-Ctrl-k-放掉-再按v"><a href="#2-Ctrl-k-放掉-再按v" class="headerlink" title="2.Ctrl+k,放掉,再按v"></a>2.Ctrl+k,放掉,再按v</h3><h3 id="3-Ctrl-Shift-v"><a href="#3-Ctrl-Shift-v" class="headerlink" title="3.Ctrl+Shift+v"></a>3.Ctrl+Shift+v</h3><h1 id="段落格式"><a href="#段落格式" class="headerlink" title="段落格式"></a>段落格式</h1><p>换行(两个以上空格加回车)<br>或者使用一个空行来表示重新开始一个段落<br><em>斜体文字</em><br><em>斜体文字</em><br><strong>粗体文字</strong><br><strong>粗体文字</strong><br><strong><em>粗斜体文字</em></strong><br><strong><em>粗斜体文字</em></strong><br>三个以上的星号、减号、底线来建立一个分割线，行内不能有其它东西，星号或减号中间可以插入空格</p><hr><hr><hr><hr><hr><hr><p><del>删除线,不明显吗?</del><br><u>下划线</u><br>我要学习 [^what]<br>[^what]:我要学习！！</p><ul><li><input checked="" disabled="" type="checkbox"> 我要好好学习  <ul><li><input disabled="" type="checkbox"> 还没学呢<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2></li></ul></li></ul><ul><li>第一项  </li><li>第二项  </li><li>第三项  </li></ul><ul><li>第一项  </li><li>第二项  </li><li>第三项  </li></ul><ul><li>第一项  </li><li>第二项  </li><li>第三项  <h2 id="有序列表-数字加"><a href="#有序列表-数字加" class="headerlink" title="有序列表(数字加.)"></a>有序列表(数字加.)</h2></li></ul><ol><li>第一项  </li><li>第二项  </li><li>第三项  <h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2>列表嵌套只需在子列表中的选项添加四个空格即可  </li><li>第一项<ul><li>第一一项</li><li>第一二项</li></ul></li><li>第二项<ul><li>第二一项</li><li>第二二项<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1>Markdown区块引用是在段落开头使用&gt;符号，然后后面紧跟一个空格符号：<blockquote><p>区块引用  </p><blockquote><p>我要学习  </p><blockquote><p>学的不仅是技术更是梦想  </p></blockquote></blockquote></blockquote><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h3 id="如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：-print-函数"><a href="#如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：-print-函数" class="headerlink" title="如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：  print()函数"></a>如果是段落上的一个函数或片段的代码可以用反引号把它包起来，例如：  <code>print()</code>函数</h3><h3 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h3><h4 id="代码区块使用4个空格或者一个制表符，例如："><a href="#代码区块使用4个空格或者一个制表符，例如：" class="headerlink" title="代码区块使用4个空格或者一个制表符，例如："></a>代码区块使用4个空格或者一个制表符，例如：</h4>private void Toast(Context context, Sting message) {<br>  Toast.makeText(context,string,Toast.LENGTH_SHORT).show();<br>}<h4 id="也可以用-包裹一段代码，并指定一种语言，（也可以不指定）："><a href="#也可以用-包裹一段代码，并指定一种语言，（也可以不指定）：" class="headerlink" title="也可以用```包裹一段代码，并指定一种语言，（也可以不指定）："></a>也可以用```包裹一段代码，并指定一种语言，（也可以不指定）：</h4><pre><code class="hljs javascript">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    alert(<span class="hljs-string">'RUNOOB'</span>);&#125;);</code></pre><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1></li></ul></li></ol><ul><li>这是我的博客<a href="https://i.csdn.net/" target="_blank" rel="noopener">CSDN</a>  </li><li><a href="https://i.csdn.net/" target="_blank" rel="noopener">https://i.csdn.net/</a></li><li>高级链接，可以通过变量来设置一个链接，变量赋值在文档末尾进行：<ul><li>这个是我的博客地址<a href="https://i.csdn.net/" target="_blank" rel="noopener">CSDN</a><h1 id="图片-bu-shi-tai-hao"><a href="#图片-bu-shi-tai-hao" class="headerlink" title="图片(bu shi tai hao)"></a>图片(bu shi tai hao)</h1><h3 id="Markdown图片语法格式如下："><a href="#Markdown图片语法格式如下：" class="headerlink" title="Markdown图片语法格式如下："></a>Markdown图片语法格式如下：</h3><pre><code class="hljs markdown">![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址</span>)![<span class="hljs-string">alt 属性文本</span>](<span class="hljs-link">图片地址"可选标题"</span>)</code></pre><h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><h3 id="Markdown制作表格使用-来分隔不同的单元格，使用-来分隔表头和其它行。"><a href="#Markdown制作表格使用-来分隔不同的单元格，使用-来分隔表头和其它行。" class="headerlink" title="Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其它行。"></a>Markdown制作表格使用|来分隔不同的单元格，使用-来分隔表头和其它行。</h3>语法格式如下：  <pre><code class="hljs gherkin">|<span class="hljs-string">  表头   </span>|<span class="hljs-string"> 表头  </span>||<span class="hljs-string">  ----  </span>|<span class="hljs-string"> ----  </span>||<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>||<span class="hljs-string"> 单元格  </span>|<span class="hljs-string"> 单元格 </span>|</code></pre><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></li></ul></li></ul><h3 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h3><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。  </li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><ul><li>支持HTML元素</li><li>反斜杠转义</li></ul>]]></content>
    
    
    <categories>
      
      <category>Study-New</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git指令</title>
    <link href="/2020/07/01/git%E6%8C%87%E4%BB%A4/"/>
    <url>/2020/07/01/git%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h2><h3 id="1-设置Git使用时的姓名和邮箱地址"><a href="#1-设置Git使用时的姓名和邮箱地址" class="headerlink" title="1. 设置Git使用时的姓名和邮箱地址"></a>1. 设置Git使用时的姓名和邮箱地址</h3><pre><code>+ git config -- global user.name name+ git config -- global user.email email</code></pre><h3 id="2-查看Git姓名和邮箱地址"><a href="#2-查看Git姓名和邮箱地址" class="headerlink" title="2. 查看Git姓名和邮箱地址"></a>2. 查看Git姓名和邮箱地址</h3><pre><code>+ git config -- user.name+ git confit -- user.email</code></pre><h3 id="3-基本操作"><a href="#3-基本操作" class="headerlink" title="3. 基本操作"></a>3. 基本操作</h3><pre><code>+ git init 初始化仓库+ git status 查看仓库的状态+ git add 向缓存区添加文件+ git commit -m &apos;描述&apos; 保存仓库的历史记录+ git log 查看提交日志+ git log --pretty=short 只显示提交信息的第一行+ git log &apos;filename&apos; 只显示指定目录、文件的日志+ git log -p 显示文件的改动+ git diff 查看更改前后的区别 **不妨在执行git commit之前先执行git diff HEAD查看本次提交与上次提交有什么区别**+ git branch 显示分支一览表+ git checkout -b 创建切换分支 git branch name, git checkout name+ git checkout - 切换回上一个分支+ git merge 合成分支 为了在历史记录中明确记录下本次分支合并，需要在合并时加上参数no-ff+ git log --graph 以图表形式查看分支+ git reset --hard 回溯历史版本+ git reflog 查看当前仓库的操作日志，以便找到误操作的哈希值+ git commit --amend 修改提交信息 在合并特性分支之前，如果发现已提交的内容有些小错误，不妨提交一个修改，然后将这个修改包含到前一个提交之中，压缩成一个历史记录+ git rebase -i 压缩历史 git rebase -i HEAD~2 用此命令可以选定当前分支包含HEAD（最新提交）在内的两个最新历史记录为对象，并在编辑器中打开+ git remote add &apos;远程仓库的名字(origin)&apos; &apos;github链接&apos; 将本地仓库与远端仓库建立一个链接+ git push -u &apos;远程仓库的名字&apos; &apos;当前分支的名字&apos; 推送更新+ git clone &apos;项目链接&apos;+ git pull 获取最新的远程仓库分支</code></pre>]]></content>
    
    
    <categories>
      
      <category>Study-New</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows、Ubuntu双系统正确卸载Ubuntu系统</title>
    <link href="/2020/07/01/Windows%E3%80%81Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%AD%A3%E7%A1%AE%E5%8D%B8%E8%BD%BDUbuntu%E7%B3%BB%E7%BB%9F/"/>
    <url>/2020/07/01/Windows%E3%80%81Ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%AD%A3%E7%A1%AE%E5%8D%B8%E8%BD%BDUbuntu%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<p>前几天突然想起了电脑上安装了很久的 Ubuntu 系统，细细一想好像也没什么用了，就在虚拟机上装了一个 Ubuntu 系统，顺便把电脑上的给卸载了。方法如下：  </p><h3 id="判断启动方式"><a href="#判断启动方式" class="headerlink" title="判断启动方式"></a>判断启动方式</h3><ul><li>以管理员身份打开cmd，输入 <code>bcdedit</code>，找到 path 行，如果是 winload.efi 就是 uefi 引导，如果是 winload.exe 就是 legacy 引导。</li><li>win+r 然后输入 <code>msinfo32</code> 找到bios模式，如果显示为传统，就是 legacy 引导，否则就是 uefi 引导。</li></ul><h3 id="legacy-启动"><a href="#legacy-启动" class="headerlink" title="legacy 启动"></a>legacy 启动</h3><p>此启动模式卸载 Ubuntu 时需使用 mbrfix。  </p><ol><li>进入 windows，将 mbrfix 放在 C:\windows\system32 文件夹中</li><li>以管理员身份启动命令提示符</li><li>在命令提示符中输入 <code>MbrFix/drive 0 fixmbr/</code>，在提示输入后输入 yes。</li><li>上一步无误则搜索“创建并格式化硬盘分区”，删除 Ubuntu 系统对应几个分区。</li></ol><h3 id="uefi-启动"><a href="#uefi-启动" class="headerlink" title="uefi 启动"></a>uefi 启动</h3><p>此启动模式需使用 <a href="https://www.easyuefi.com/index-us.html" target="_blank" rel="noopener">easyUEFI</a>，下载安装后运行，找到 Ubuntu 删除，重启电脑，执行上一模式第四步即可。  </p><hr><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>我安装设置引导时使用了 easyBCD 软件，卸载时在按照 legacy 启动卸载时，重启后，仍会进入系统选择页面，在使用 easyBCD 软件删除 Ubuntu 的引导文件后，重启后便直接进入 windows 系统，然后按照上述方法删除 Ubuntu 系统硬盘分区。</li><li>uefi 启动模式的卸载，我没有试验过，方法是搜索而来，有效性未知。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反射</title>
    <link href="/2020/07/01/%E5%8F%8D%E5%B0%84/"/>
    <url>/2020/07/01/%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="Java-中的-Class-类"><a href="#Java-中的-Class-类" class="headerlink" title="Java 中的 Class 类"></a>Java 中的 Class 类</h3><p> <code>Class</code> 类的构造方法是私有的，无法在代码中显式的生命一个 <code>Class</code> 对象</p><h4 id="获得-Class-类的对象"><a href="#获得-Class-类的对象" class="headerlink" title="获得 Class 类的对象"></a>获得 <code>Class</code> 类的对象</h4><ul><li>通过类的静态成员表示，每个类都有一个隐含的静态成员 <code>class</code></li><li>通过类的 <code>getClass()</code> 方法，和上类似</li><li>通过 <code>Class</code> 类的静态方法 <code>forName()</code> 获取 <code>Class</code> 对象（可实现程序运行时类的动态加载）  </li></ul><a id="more"></a><h4 id="由-Class-类的对象得到类的对象"><a href="#由-Class-类的对象得到类的对象" class="headerlink" title="由 Class 类的对象得到类的对象"></a>由 <code>Class</code> 类的对象得到类的对象</h4><p><code>newInstance()</code> 方法，此方法调用类的 <strong>无参构造函数</strong></p><h3 id="Java反射机制"><a href="#Java反射机制" class="headerlink" title="Java反射机制"></a>Java反射机制</h3><p><a href="https://juejin.im/post/598ea9116fb9a03c335a99a4#heading-11" target="_blank" rel="noopener">参考自</a></p><blockquote><p>Java 反射机制在程序运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性。这种 动态的获取信息 以及 动态调用对象的方法 的功能称为 java 的反射机制。</p></blockquote><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><ul><li><code>getFields()</code> 获取所有 public 访问权限的变量</li><li><code>getDeclaredFields()</code> 获取所有本类声明的变量  </li><li><code>getDeclaredField(参数名)</code> 获取私有变量  </li></ul><p>以下方法对变量对象调用</p><ul><li><code>getModifiers()</code> 获取变量的访问权限</li><li><code>getType().getName()</code> 获取变量的类型</li><li><code>getName()</code> 获取变量名</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul><li><code>getMethods()</code> 获取所有 public 访问权限的方法</li><li><code>getDeclaredMethods()</code> 获取所有本类的方法  </li></ul><p>以下方法对方法对象调用  </p><ul><li><code>getModifiers()</code> 获取方法的访问权限</li><li><code>getReturnType()</code> 获取方法的返回值类型</li><li><code>getParameters()</code> 获取方法的所有参数<ul><li><code>getType().getName()</code> 获取方法参数的类型</li><li><code>getName()</code> 获取方法参数名</li></ul></li><li><code>getExceptionTypes()</code> 获取方法抛出的异常</li><li><code>getDeclaredMethod(方法名，[参数类型])</code> 获取私有方法  </li><li><code>setAccessible(true)</code> 获取私有方法的访问权限</li></ul>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
      <tag>进阶</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《无限制神话》读后有感</title>
    <link href="/2020/07/01/%E3%80%8A%E6%97%A0%E9%99%90%E5%88%B6%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/"/>
    <url>/2020/07/01/%E3%80%8A%E6%97%A0%E9%99%90%E5%88%B6%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%BB%E5%90%8E%E6%9C%89%E6%84%9F/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">你应该不知道密码的吧！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="da3f056edb29b68841081e6a96ebf57827205598b13630c60dbee321068cca64">e354f7a8214c5d26de7de051df65d95bb4a6bf268bf8db997cd7c5c03927be5c91489959d11228a8e9f48c71f0fba2e69eda9db6dd719d397fdbcf947ae378d84546723bcdde034c68ae52f24a208547b53a74ad4c753f6a31fb696c9e4960293b98a6c55b7d1d5083997020f134c656894767e4cec969de6871c86069676cc5444a2d9c573edfb4b7a65740c357d77cb6edde6dc67c421f7780bf34276db77e4a5c05532a3ce1fa2b611876c453dd54367ab3c6e766e0993a20d741cd29debaf2cc778224ae87c6c1c668c81fc3fb303b8fb15403c4eda0069feabe89ca4634ec8fd17719934f42962f5a7e5d75e07403d1337393054776928daae30c147d185c488c42ccd7ea4aefb3492445d3626ab262862f6ee7d6480b8b1c31d373d3e7aae975a58aaf8ab5a77e370e06967b7d7c2c6723c36292a5c5cbbc25ce63d5edbbc4597a8fa43c3cde3b771564b2d3fb3e86d080b686b0c5f8f4c1632a3c304a503e81f0bfa313409017d97744b52e156b1b15ffeaf2c8e6b9ceb0b823813d03e2439401190fa83c427d40cb843ec943546ef197b88f2ac2d9e01769d355fdab367e18bbe76b990bfa668dc0d53be585f545ef38a4d4b01c9d4490f9c4cd4570577e043159d861e95df05d5f6704de8fffb4679e4eb01ee741dcaf861c473aae9a271a69d6a1e66707443601eecddc48eeb565ace7d904b9b1c58754399260788f82f13b0387589b6fafbbac2676e7763a7be13f7c063d46f748af15cc1e70d56834d6bbbc84e2c69a73cac8651aa174c0643b2da3ee2c8c2838fec103fb73e858e81b66e51ce7f08f251547a876aba3f8c5c78d09a09bce9ebd6b9bdbd343f686d62d174de154d55401c0734df50d13ded73df431fb465a1eb93ff50348d91e1dad650cbf767aaa6b22b9f9f2230ff56996bdeb525871cd0ff4d66006c8cc4acedcef569a4dca363af04fd18a96cfc99a8e039493e99f08a75034c01d0ccb3082327f5dc6e878137dc01ce03fa392eaf2f672c09bd46201aa23f4f0eaf3479272877b365958834fb663f8d37fdb2bd7f93e615640834e48e6da07e7af3962527b02a10412a33fa925826e968203c2abc57a890715e2b18c824d015aab5036e4cb63e3cc3ebf004c70b606527dbf1858a4c74679123b48748df515adfb41efb6de1fc409e180f5977f1f75998747d52b37e177fc7e0d8dad49e9669bca6f7608aaf26dc33b4d620ca54e7c81a84ceded8034b23ba076bbcfe334840059f729b20574da71f719caca0eb0a294a8c6d287da18cf0abf522467656f6d18d90809aadaf1262f75c9a9edc18d268b24f661303c14c819bff37151233e2c5eb02fa9fcfd6fe94b7b5913b823776273baee561b6f054b937c7f2832d99762dbb6d8f151255ccb3ca25a784df71247266138702fd04ff40c68891c7ae57e826c7c49535bf4779b09632522d1ff852cc68631d7c181c8f46c05287fd848860eca59fbb05daee83b2396c713a47dbb9e69012aeb6a332c3c8a26125a1b5c8d90144495ea9ba2914e08c8b5cae4fda17666ca2f7a58251660db1775c4945b31636f504ff88701a60918acca3bd96dfc9d2bec21087fba76d9bcbaf63de0c052cec3e4405b6366055381dec8f1bafb9dfdcf5b117b2341aef504bc3bd3740ea85a83ff936e938a55c745bcf821fe407473f9278b862c5cd180702c8798d3daa6596ec8a1f54d302e120b5d995ee4d2c21e27fccdadfdbcf7c329061c310ab707818541eebfaaf19eeccd411fd590eab41acf8bc050dc3e1720f1059f3826bd56018cc93340a0cefc7ed04902dfb91cf6e19049ba24db8b9b0887c1ef27eb872c506bf383c49a0d14637e555ca00abc3e497f9eaf3b02756f62ede15a3b912069bfbb6a914564199db083df5a96652b1427be5e6e99178971b06cfc8683bd03934f693f06aa74ac5dad9445d92a68f9467f9d05cce1b4e6f966381d71c55e4bd23790b4407acd9a5c8e217ba63410daff947b470e8b5e4b853571adf54b5980feea31552af46670372fa4ce1f31ed28fcd0a6358b36f32deba34792c679cb66245c043caee6601dfd3cd5cd3ebe188f4ad201a086fa9c5a0144963d31cd1814221632e5deb789925a52b3a056914ee04776693380887cb76e04ed2388627a341535052279ea8ffb8cc62ae34de6855874a39192022f87a8039f3c60973c2f8f7448b76bcc8177d05de44b46539438dcea88a75d62bb69aded35c377c139ff07820e1db46aab33d45ac5621626560ed0388762cf11c3753c4a4ddce0733621df754ef2048bd61417e2a347ec69da0f0524277f8cfe125a5956a00647d80ae1aafca0d726129f91abe5eca1c40a1e33dce8fd9bb3be593544f87503d61f2ed9c8377cc8da8c4015ead856674a55e5ddbe70c738c35335ebcfeede963614661c468f2d99a61a4b7c4673c52d0f0f05bebbff111ac86875e78605eec541b765652b68f99524fb36cb51393319385cd22c2c060d75dcae988fe7d12378668ae257ef8a8b86f2d07543d0b0a4da1e7e76acf6ef76fbe86a1dacea19fba2be847608ac77e5162893a1fb87eddb20e03c84abb67cd92ae10a92e276f42b9896ecff3c9ca2d2e849425dc7e17d6233f1265992fe324edcac5869a8888d07d6ad262832ef53961e0e985f8c35d2cc0d7d2dffb7d76c78e9d8eeb45597aa067cf6d1701736dc9e17d5ac4ec7</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>阅读笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>阅读笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git 如何清除所有commit记录</title>
    <link href="/2020/07/01/git-%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89commit%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/07/01/git-%E5%A6%82%E4%BD%95%E6%B8%85%E9%99%A4%E6%89%80%E6%9C%89commit%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>在错误的折腾了几天博客后，发现仓库里有了100多次commit记录，因此就找到了把记录清除的方法：</p><ol><li>建立孤立的分支 <code>git checkout --orphan latest_branch</code></li><li>添加所有文件 <code>git add -A</code></li><li>提交更改 <code>git commit -m &quot;commit message&quot;</code></li><li>删除分支 <code>git branch -D master</code></li><li>将分支重命名 <code>git branch -m master</code></li><li>强制更新 <code>git push -f origin master</code></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>三日记</title>
    <link href="/2020/06/30/2020-06-30%20%E4%B8%89%E6%97%A5%E8%AE%B0/"/>
    <url>/2020/06/30/2020-06-30%20%E4%B8%89%E6%97%A5%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">你应该不知道密码的吧！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="8c5e30740dbd83f50251152a03839eddd8ac3bd93867f83208c332271dc73596">ae6afac3d160296fa0e154342e43c973e75d45594a846b385f3f0438a5e4faac812cabeeb01a13f8caf74b9d7a633f27d9955fa070deeed4d96ea2129460af463d1b9033275acec052b99ec7282f0d9ee9cc39232b83c51e8332ece1eb3f983e7830538b46bd815af9d934f09866a073ab1422f8c5e987421a5d3b7f0327b17a0d0bb4b1cde8c8b161617b96b546cd0a64c0dd2dc54da5aea5a4268dcac8045d32337cd90f2f60692e0c7229f63c111855fa5bc4cf0e3f9468855a41622f78c59f73a94c0b4d975c298f597f8f46f4e4912d1c175e79b37e0760a68d34e83f49aea7431f736b448f13bc111e761b7af5163cba2cacc809636b25fb925220e5db9eef408bb74b9f2c1b8ae6cfd29b60ba527f65fd17898293a47179564cbc24150590704c8e530d84312c99c37c6be61f159c7df9cdf7875160d3234ee25a2fb2fbc560e389e368230977eb7512328f451d30829fc8dcaa9bcf380e61c67713901d284a588caa6f8390d31380325927bbea5b5439420e63ac90bb648b5a02fe631667a9dbdeff646d016e64e821431c5fd3ea690d645c4fb4be61960f20639b9c856b28a12e62b7e2de712e622096ee389d4fba79f581b869cc11745b32ab0ce9423fa32e91c8621818e7646dca62b18a1b8a955f4bed4e9b9770c783d44cafc89f35a8ceca8d5bd6e981db87174507516176ac0085a57e637ec5d260ad8c916e98c329f977112e5f47654463e49b806de1a0668e3c9984f070202e52743091396b3def5a330378643a05abfe67bf3bcfe9d1e1389c080ef03ef2c4678460b768b5f5a252832712e5dd715058452ed52f1492b8a4b8a69becd0b17ce461b8d13b8ffc585b98764f2dac1d606ab8923657031cb78093faa4ee8d78f2132fb894846d71ed7af719977f920272295e3b40f8147d8fb9693f949019d91c44a8a109fe53ff76f1ba7dde4f96bbd78e66cbe5b4c8224a480002763fe9f50c359609da2e6aa2e6d5dc465e24811100de8c38f7979491e6b45a3f93edcef6d3ae823ac60cfb6b76c3382f7589e55f8b4c32f107c83030a22d1a1a1d42910d2458b2d90d980b4ff2b12180e1d14c993fcce739e2e8ccbba6aa12fdfe9285a447a77c6ae3d67302e6ad375ff574d352b4beee943b664665ea4b22e471da946882cde1ff7aba4b2adc194bc3ca3b1e9e5deb15075efc8604be6794360db412db6d51d775e624aa0d597b289461557ad738b6bf2eb7b7d0bd28c51d0a44b8ddedff93f2d6b84003acf263165573b5b1a938808ac664fb6cc1a9177778cc06c2d4ac1422ad7067568395aef3767b18cefc33c5f53a6945807ffdb5bb46e62c9c9bb13364c14bc79909f8c98976059e572733a15682ea514f8a42ca7949455b9402a7785d3451843be9eb08ab7556dd8924b8d857a3b23c309c59eabd05c0101b524dc37a91bc9e</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fluid使用</title>
    <link href="/2020/06/29/fluid%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/06/29/fluid%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="文章摘要"><a href="#文章摘要" class="headerlink" title="文章摘要"></a>文章摘要</h3><p>若要手动指定摘要，使用 <code>&lt;!--more--&gt;</code> MD文档里划分，或者在 Front-matter 里设置 <code>excerpt</code> 字段。</p><a id="more"></a><h3 id="文章在首页的略缩图"><a href="#文章在首页的略缩图" class="headerlink" title="文章在首页的略缩图"></a>文章在首页的略缩图</h3><p>在文章开头 Front-matter 中配置 <code>index_img</code> 属性。</p><h3 id="文章页顶部大图"><a href="#文章页顶部大图" class="headerlink" title="文章页顶部大图"></a>文章页顶部大图</h3><p>默认显示主题配置中的 <code>post.banner_img</code>，如需要设置单个文章的 Banner，在 Front-matter 中指定 banner_img 属性。</p><h3 id="文章内容图片"><a href="#文章内容图片" class="headerlink" title="文章内容图片"></a>文章内容图片</h3><pre><code class="hljs less">!<span class="hljs-selector-attr">[]</span>(/img/example.jpg)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo命令</title>
    <link href="/2020/06/29/hexo%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/29/hexo%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p><code>hexo init [folder]</code> 新建一个网站。如果没有 <code>folder</code>，Hexo默认在当前文件夹建立网站。  </p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>hexo new [layout] &lt;title&gt;</code>  </p><a id="more"></a><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 _config.yml 中的 <code>default_layout</code> 参数代替。<strong>如果标题包含空格的话，请使用引号括起来。</strong></p><table><thead><tr><th>参数</th><th align="center">描述</th></tr></thead><tbody><tr><td><code>-p</code>,<code>--path</code></td><td align="center">自定义新文章的路径</td></tr><tr><td><code>-r</code>,<code>--replace</code></td><td align="center">如果存在同名文章，将其替换</td></tr><tr><td><code>-s</code>,<code>--slug</code></td><td align="center">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p><code>hexo generate</code> 生成静态文件。</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-d</code>,<code>--deploy</code></td><td align="center">文件生成后立即部署网站</td></tr><tr><td align="center"><code>-w</code>,<code>--watch</code></td><td align="center">监视文件变动</td></tr><tr><td align="center"><code>-b</code>,<code>--bail</code></td><td align="center">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="center"><code>-f</code>,<code>--force</code></td><td align="center">强制重新生成文件 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td align="center"><code>-c</code>,<code>--concurrency</code></td><td align="center">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><p><code>hexo publish [laytout] &lt;filename&gt;</code> 发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p><code>hexo server</code> 启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p><table><thead><tr><th align="center">选项</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-p</code>,<code>--port</code></td><td align="center">重设端口</td></tr><tr><td align="center"><code>-s</code>,<code>--static</code></td><td align="center">只使用静态文件</td></tr><tr><td align="center"><code>-l</code>,<code>--log</code></td><td align="center">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><p><code>hexo deploy</code> 部署网站。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-g</code>,<code>--generate</code></td><td align="center">部署之前预先生成静态文件</td></tr></tbody></table><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><p><code>hexo render &lt;file1&gt; [file2] ...</code> 渲染文件。</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>-o</code>,<code>--output</code></td><td align="center">设置输出路径</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><p><code>hexo migrate &lt;type&gt;</code> 从其他博客迁移内容。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><p><code>hexo clean</code> 清除缓存文件(<code>db.json</code>)和已生成的静态文件(<code>public</code>)。<br>在某些情况（尤其是更新主题后），如果对站点的更改无论如何也不生效，可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>hexo list &lt;type&gt;</code> 列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p><code>hexo version</code> 显示 Hexo 版本。</p><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><h4 id="安全模式"><a href="#安全模式" class="headerlink" title="安全模式"></a>安全模式</h4><p><code>hexo --safe</code> 在安全模式下，不会载入插件和脚本。在新安装插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h4><p><code>hexo --debug</code> 在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p><h4 id="简洁模式"><a href="#简洁模式" class="headerlink" title="简洁模式"></a>简洁模式</h4><p><code>hexo --silent</code> 隐藏终端信息。  </p><h4 id="自定义配置文件的路径"><a href="#自定义配置文件的路径" class="headerlink" title="自定义配置文件的路径"></a>自定义配置文件的路径</h4><pre><code class="hljs routeros"><span class="hljs-comment"># 使用 custom.yml 代替默认的 _config.yml</span>$ hexo<span class="hljs-built_in"> server </span>--config custom.yml<span class="hljs-comment"># 使用 custom.yml 和 custom2.json，其中 custom2.json 优先级更高</span>$ hexo generate --config custom.yml,custom2.json,custom3.yml</code></pre><p>当指定了多个配置文件以后，Hexo 会按顺序将这部分配置文件合并成一个 <code>_multiconfig.yml</code>。如果遇到重复的配置，排在后面的文件的配置会覆盖排在前面的文件的配置。这个原则适用于任意数量、任意深度的 YAML 和 JSON 文件。</p><h4 id="显示草稿"><a href="#显示草稿" class="headerlink" title="显示草稿"></a>显示草稿</h4><p><code>hexo --draft</code> 显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p><h4 id="自定义CWD"><a href="#自定义CWD" class="headerlink" title="自定义CWD"></a>自定义CWD</h4><p><code>hexo -cwd/path/to/cwd</code> 自定义当前工作目录（Current working directory）的路径。</p>]]></content>
    
    
    <categories>
      
      <category>Study-New</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo搭建博客</title>
    <link href="/2020/06/29/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/06/29/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>在安装 Hexo 之前，需要安装以下两个工具：</p><ul><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li></ul><p>安装好后，使用 npm 完成 Hexo 的安装<br><code>npm install -g hexo-cli</code></p><a id="more"></a><h4 id="建立网站"><a href="#建立网站" class="headerlink" title="建立网站"></a>建立网站</h4><p>首先建立一个文件夹。<br><code>mkdir &lt;folder</code><br>然后向此文件夹安装Hexo。<br><code>hexo init &lt;folder&gt;</code>  </p><h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><h5 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h5><ol><li>在 Github 新建一个名称为 <code>username.github.io</code> 的仓库。  </li><li>安装部署插件  <pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-deployer-git <span class="hljs-comment">--save</span>npm <span class="hljs-keyword">install</span> hexo-<span class="hljs-keyword">server</span> <span class="hljs-comment">--save</span></code></pre></li><li>配置站点 <code>_config.yml</code> 文件<pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><span class="hljs-symbol">    type:</span> git<span class="hljs-symbol">    repo:</span> <span class="hljs-params">&lt;repository url&gt;</span><span class="hljs-symbol">    branch:</span> master<span class="hljs-symbol">    message:</span> <span class="hljs-meta">#提交信息，默认为提交时间</span></code></pre></li><li>发布到 Github<br>在 Hexo 站点根目录下执行以下命令：<br><code>hexo clean &amp;&amp; d -g</code>  </li></ol><ul><li>此教程，只是为了自己记录，略有缩减，<a href="https://easyhexo.com/1-Hexo-install-and-config/" target="_blank" rel="noopener">详见:</a>  </li><li>国内使用 npm 有时会很慢，可以转为淘宝镜像，命令除 npm 转为 cnpm 外，别无二样。<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>Other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>搭建博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>22:43</title>
    <link href="/2020/06/28/2020-06-28%2022-43/"/>
    <url>/2020/06/28/2020-06-28%2022-43/</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被校验，不过您还是能看看解密后的内容。">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">你应该不知道密码的吧！</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="3b888e6d775864ce23ff9e358df5ecadc54edc7ac0bb906d41d37e22cd835870">e2a2bc5ef0b8aaf1ba637856e613f5a247271f576efb0cf94ceb607b19b59249c6e5f583e5f90a6d03eaedb029366a42e3a8f40b211aabdcd3ce94cedce3ee18f82ae0c784e0c39391bf9b5324a5f3dc334dfe7247565530581e7b2439f3ead398b9bc72f2e30c230355096e609dcee2ae407947ff525aa9dd253d32bea680259dcc8d82d496fab21e7fc3a7ed91242a58c92ccdb1997289f99432cffe8d8cd78523c5eb60406b4ce2fc1c92778a624484c2ffe71ea2c24354656e0dee253d392e222c01a8c62f6160eb3d0fb88b6eff979e980db80e09ac4cb4423eb8c0ee46</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
